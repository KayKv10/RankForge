# src/rankforge/schemas/game.py

"""Pydantic schemas for the Game resource."""

from enum import Enum

from pydantic import BaseModel, ConfigDict, Field


# ===============================================
# Enums
# ===============================================
class RatingStrategy(str, Enum):
    """Valid rating calculation strategies."""

    GLICKO2 = "glicko2"
    DUMMY = "dummy"


# ===============================================
# Base Schema: Defines shared attributes
# ===============================================
class GameBase(BaseModel):
    """Shared attributes for a game."""

    name: str = Field(..., min_length=2, max_length=200)
    rating_strategy: RatingStrategy
    description: str | None = Field(None, max_length=1000)


# ===============================================
# Create Schema: Defines attributes for creation
# ===============================================
class GameCreate(GameBase):
    """Properties to receive via API on create."""

    # No extra fields needed for creation, inherits all from GameBase.
    pass


# ===============================================
# Update Schema: Defines attributes for updates
# ===============================================
class GameUpdate(BaseModel):
    """Properties to receive via API on update."""

    # When updating, all fields should be optional.
    name: str | None = Field(None, min_length=2, max_length=200)
    rating_strategy: RatingStrategy | None = None
    description: str | None = Field(None, max_length=1000)


# ===============================================
# Read Schema: Defines attributes for returning data
# ===============================================
class GameRead(GameBase):
    """Properties to return to the client."""

    # The 'id' is generated by the database, so it's only in the read model.
    id: int

    # This config allows Pydantic to read data from ORM models.
    # It tells Pydantic to access fields like `game.id` instead of `game['id']`.
    model_config = ConfigDict(from_attributes=True)
